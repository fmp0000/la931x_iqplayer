diff --git a/arch/arm64/boot/dts/freescale/imx8mp-frdm.dts b/arch/arm64/boot/dts/freescale/imx8mp-frdm.dts
index d05cc2cfb8c4..6f9e6565b73a 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp-frdm.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mp-frdm.dts
@@ -23,6 +23,17 @@ memory@40000000 {
                          <0x1 0x00000000 0 0xc0000000>;
        };

+        reserved-memory {
+                la93: la93@92400000 {
+                        reg = <0 0x92400000 0 0x4000000>;
+                        compatible = "shared-dma-pool";
+                };
+
+                iqflood: iqflood@96400000 {
+                        reg = <0 0x96400000 0 0xD000000>;
+                };
+        };
+
        pcie0_refclk: pcie0-refclk {
                compatible = "fixed-clock";
                #clock-cells = <0>;
diff --git a/arch/arm64/boot/dts/freescale/imx95-15x15-frdm.dts b/arch/arm64/boot/dts/freescale/imx95-15x15-frdm.dts
index c45f28efb568..1fb94e06a7fd 100644
--- a/arch/arm64/boot/dts/freescale/imx95-15x15-frdm.dts
+++ b/arch/arm64/boot/dts/freescale/imx95-15x15-frdm.dts
@@ -65,6 +65,15 @@ linux_cma: linux,cma {
                        linux,cma-default;
                };

+                la93: la93@a1000000 {
+                        reg = <0 0xa1000000 0 0x4000000>;
+                        compatible = "shared-dma-pool";
+                };
+
+                iqflood: iqflood@a5000000 {
+                        reg = <0 0xa5000000 0 0xD000000>;
+                };
+
                vpu_boot: vpu_boot@a0000000 {
                        reg = <0 0xa0000000 0 0x100000>;
                        no-map;
diff --git a/arch/arm64/boot/dts/freescale/imx95.dtsi b/arch/arm64/boot/dts/freescale/imx95.dtsi
index 55b03d4797f4..a0b0c235e643 100644
--- a/arch/arm64/boot/dts/freescale/imx95.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx95.dtsi
@@ -2719,7 +2719,7 @@ pcie0: pcie@4c300000 {
                              <0 0x4c340000 0 0x4000>;
                        reg-names = "dbi", "config", "atu", "app";
                        ranges = <0x81000000 0x0 0x00000000 0x0 0x6ff00000 0 0x00100000>,
-                                <0x82000000 0x0 0x10000000 0x9 0x10000000 0 0x10000000>;
+                                <0x82000000 0x0 0x10000000 0x9 0x10000000 0 0x20000000>;
                        #address-cells = <3>;
                        #size-cells = <2>;
                        device_type = "pci";
diff --git a/arch/arm64/configs/imx_v8_defconfig b/arch/arm64/configs/imx_v8_defconfig
index 0e9e6dfe63d0..73465f0a382b 100644
--- a/arch/arm64/configs/imx_v8_defconfig
+++ b/arch/arm64/configs/imx_v8_defconfig
@@ -1153,3 +1153,4 @@ CONFIG_CORESIGHT_STM=m
 CONFIG_CORESIGHT_CPU_DEBUG=m
 CONFIG_CORESIGHT_CTI=m
 CONFIG_MEMTEST=y
+CONFIG_STRICT_DEVMEM=n
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b358b93a0275..5ba2dee97735 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -23,6 +23,8 @@

 #define CARDBUS_LATENCY_TIMER  176     /* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR  3
+#define IMX_LA9310_BAR_RSIZE_MASK 0xfc000000 /* For 64MB */
+#define IMX_LA9310_BAR_OFFSET 0x10

 static struct resource busn_resource = {
        .name   = "PCI busn",
@@ -209,6 +211,24 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
        if (PCI_POSSIBLE_ERROR(sz))
                sz = 0;

+       /*
+        * LA9310 device BAR0 default size 256MB is too large for imx8mp/8dxl
+        * as workaround we map only first 64MB and we will update EP BAR0_MASK
+        * at runtime before accessing BAR1-5 and avoid Bus Errors
+        */
+       if (of_machine_is_compatible("fsl,imx8mp") ||
+                       of_machine_is_compatible("fsl,imx8dxl") ||
+                       of_machine_is_compatible("fsl,imx8mm")) {
+               if ((sz < IMX_LA9310_BAR_RSIZE_MASK) &&
+                       ((dev->device == PCI_DEVICE_ID_LA9310) ||
+                       (dev->device == PCI_DEVICE_ID_LA9310_DISABLE_CIP)) &&
+                       (pos == IMX_LA9310_BAR_OFFSET)) {
+                               pci_info(dev, "reg 0x%x: forcing BAR0 readback 0x%08x to 0xfc000000 (i.e.64MB)\n",
+                                       pos,sz);
+                               sz = IMX_LA9310_BAR_RSIZE_MASK;
+               }
+       }
+
        /*
         * I don't know how l can have all bits set.  Copied from old code.
         * Maybe it fixes a bug on some ancient platform.
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index db609d26811b..32b3be21f524 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -31,6 +31,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 #include <linux/switchtec.h>
+#include <linux/of.h>
 #include "pci.h"

 /*
@@ -3742,6 +3743,114 @@ static void mellanox_check_broken_intx_masking(struct pci_dev *pdev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,
                        mellanox_check_broken_intx_masking);

+/*
+ *  set NXP LA9310 device class code
+ */
+static void quirk_la9310_cc(struct pci_dev *pdev)
+{
+
+       /* LA9310 devices do not have class code set when in PCIe boot mode */
+       if (pdev->class == PCI_CLASS_NOT_DEFINED) {
+               dev_info(&pdev->dev, "Setting PCI class for LA9310 PCIe device\n");
+               pdev->class = PCI_CLASS_NETWORK_OTHER;
+       }
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_LA9310, quirk_la9310_cc);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_LA9310_DISABLE_CIP, quirk_la9310_cc);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,
+                       mellanox_check_broken_intx_masking);
+
+#define ENABLE_INBOUND_MEM_ACCESS       0x02
+#define SET_BAR_MASK_VAL                0x3ffffff /*  64MB */
+#define SET_BAR_MASK_MP                 0x18000000
+#define PCIE_RHOM_DBI_BASE              0x3400000
+#define PCIE_CMD_REG_OFFSET             0x4
+#define PCIE_BAR_MASK_REG_0             0x1010
+#define PCIE_BAR_MASK_REG_1             0x10
+#define PCIE_HCTRL_PHY                  0x33B00000
+#define PCIE_HCTRL_OFFSET               0x214
+#define PICE_HCTRL_TRGT_IVAL            0x10000000
+#define PICE_HCTRL_TRGT_FVAL            0x18000000
+#define BOARD_TYPE_DXL                  1
+#define BOARD_TYPE_MP                   2
+#define BOARD_TYPE_IMX95                3
+
+static void quirk_la9310_config_mem(struct pci_dev *pdev)
+{
+       u32 size = 0;
+       u8 __iomem *vaddr = NULL,
+          *vaddr_hctrl = NULL;
+       phys_addr_t phys_addr = 0;
+       int8_t board_type = 0;
+
+       if ((of_machine_is_compatible("fsl,imx8mp") ||
+               of_machine_is_compatible("fsl,imx8mm"))) {
+               board_type = BOARD_TYPE_MP;
+       } else if ((of_machine_is_compatible("fsl,imx8dxl"))) {
+               board_type = BOARD_TYPE_DXL;
+       }  else if ((of_machine_is_compatible("fsl,imx95"))) {
+               board_type = BOARD_TYPE_IMX95;
+       }else {
+               pci_err(pdev, "Unkown board !\n");
+               return;
+       }
+       if (board_type == BOARD_TYPE_MP) {
+               pci_info(pdev, "%s board_type: i.MX8MP/i.MX8MM\n",__func__);
+       }
+       else if (board_type == BOARD_TYPE_DXL) {
+               pci_info(pdev, "%s board_type: i.MX8MP/i.MX8MM\n",__func__);
+       }
+       else if (board_type == BOARD_TYPE_IMX95) {
+               pci_info(pdev, "%s board_type: i.MX95\n",__func__);
+       }else {
+               pci_err(pdev, "Unkown board !\n");
+               return;
+       }
+
+       if (pci_enable_device_mem(pdev)) {
+               pci_err(pdev, "Can't enable device memory\n");
+               return;
+       }
+
+       if (board_type == BOARD_TYPE_IMX95) {
+                return;
+       }
+
+       phys_addr = pci_resource_start(pdev,0);
+       size = pci_resource_len(pdev, 0);
+       vaddr = ioremap(phys_addr, size);
+       if (!vaddr) {
+               pci_err(pdev, "ioremap failed !");
+               goto out;
+       }
+
+       if (board_type == BOARD_TYPE_MP) {
+               vaddr_hctrl = ioremap(PCIE_HCTRL_PHY, 1024);
+               iowrite32(PICE_HCTRL_TRGT_IVAL, (u32 *)(vaddr_hctrl +
+                                       PCIE_HCTRL_OFFSET));
+       }
+
+       iowrite16(ENABLE_INBOUND_MEM_ACCESS, (u32 *)(vaddr +
+                               PCIE_RHOM_DBI_BASE + PCIE_CMD_REG_OFFSET));
+       iowrite32(SET_BAR_MASK_VAL, (u32 *)(vaddr +  PCIE_RHOM_DBI_BASE +
+                               PCIE_BAR_MASK_REG_0));
+       if (board_type == BOARD_TYPE_MP) {
+               iowrite32(SET_BAR_MASK_MP,(u32 *)(vaddr +  PCIE_RHOM_DBI_BASE +
+                               PCIE_BAR_MASK_REG_1) );
+               iowrite32(PICE_HCTRL_TRGT_FVAL, (u32*)(vaddr_hctrl +
+                                       PCIE_HCTRL_OFFSET));
+               iounmap(vaddr_hctrl);
+       }
+
+       iounmap(vaddr);
+out:
+       pci_disable_device(pdev);
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE,
+               PCI_DEVICE_ID_LA9310_DISABLE_CIP, quirk_la9310_config_mem);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE,
+               PCI_DEVICE_ID_LA9310, quirk_la9310_config_mem);
+
 static void quirk_no_bus_reset(struct pci_dev *dev)
 {
        dev->dev_flags |= PCI_DEV_FLAGS_NO_BUS_RESET;
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 59568da82e6e..d26e14ea7b5d 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2541,6 +2541,8 @@
 #define PCI_DEVICE_ID_MPC8641          0x7010
 #define PCI_DEVICE_ID_MPC8641D         0x7011
 #define PCI_DEVICE_ID_MPC8610          0x7018
+#define PCI_DEVICE_ID_LA9310           0x1c10
+#define PCI_DEVICE_ID_LA9310_DISABLE_CIP 0x1c12

 #define PCI_VENDOR_ID_PASEMI           0x1959

